# 🏆 常用竞赛语法与算法 Workshop 简介

## 一、快读快写（Fast I/O）

**问题引入：**  
当我们在处理百万级输入输出（如 `n ≤ 10^6`）时，如果使用 `cin >>` 或 `input()`，程序可能超时。

**思路分析：**  
输入输出在 C++/Python 中都可能成为瓶颈。解决办法是使用更底层、更高效的读写接口。

**方法讲解：**

- **C++：**

  ```cpp
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  ```

  或使用 `getchar_unlocked()`、`fread()` 实现手写快读。

- **Python：**

  ```python
  import sys
  input = lambda: sys.stdin.readline().strip()
  ```

  输出时可用 `sys.stdout.write()`。

**总结：**  
快读快写的本质是**减少系统调用次数**。在竞赛中，当时间卡在 1s 附近时，它常常能救命。

---

## 二、数据范围与复杂度分析

**问题引入：**  
如果 `n = 10^6`，你写了一个 `O(n^2)` 的算法，会怎样？——超时。

**思路分析：**  
每个题目的数据范围都暗示着**可接受的算法复杂度**。

| 数据范围 | 可接受复杂度 |
| -------- | ------------ |
| ≤ 10^3   | O(n³) 或更优 |
| ≤ 10^5   | O(n log n)   |
| ≤ 10^7   | O(n)         |

**方法讲解：**  
读题时先看 `n` 最大是多少，再决定是否能枚举、排序或用更快算法。

**总结：**  
竞赛第一步不是写代码，而是**估算复杂度能否过**。

---

## 三、模拟（Simulation）

**问题引入：**  
如果题目要求“根据一系列规则模拟操作过程”，比如“石头剪刀布循环对决”或“蛇形矩阵”，怎么办？

**思路分析：**  
这类题一般不需要算法优化，只要**照规则实现**。但关键是要**清晰建模**和**防止细节错误**。

**方法讲解：**

- 明确状态（位置、方向、计数器等）
- 按顺序执行题目规则
- 用数组或队列维护动态状态

**总结：**  
模拟题考察的是**代码逻辑性与严谨性**。建议：

> “把题意翻译成代码，而不是脑补。”

### 举例：蛇形矩阵

- **问题描述**：生成一个 `n x n` 的蛇形矩阵，如 `n=3` 时：

  ```text
  1 2 3
  6 5 4
  7 8 9
  ```

- **思路**：按行填充，偶数行从左到右，奇数行从右到左。
- **实现**：

  ```cpp
  for (int i = 0; i < n; ++i) {
      if (i % 2 == 0) {
          for (int j = 0; j < n; ++j)
              matrix[i][j] = i * n + j + 1;
      } else {
          for (int j = 0; j < n; ++j)
              matrix[i][n - j - 1] = i * n + j + 1;
      }
  }
  ```

---

## 四、高精度（Big Integer）

**问题引入：**  
`10^100` 这种数显然超出 `long long` 范围，怎么办？

**思路分析：**  
我们可以把**大数看作字符串**，手动实现加减乘除。  
例如：

```text
"123" + "45" → 模拟竖式计算
```

**方法讲解：**

- 用数组或字符串存储每一位；
- 从最低位向最高位运算；
- 注意进位与符号。

**C++：**

```cpp
vector<int> add(vector<int> a, vector<int> b) { ... }
```

**总结：**  
高精度的本质是**人工实现整型的底层逻辑**。  
常见应用：阶乘、组合数、任意精度计算。

---

## 五、贪心（Greedy）

**问题引入：**  
假设有一堆活动，每个活动有开始和结束时间，如何安排最多的活动？

**思路分析：**  
我们发现如果总是选择**最早结束**的活动，就能留下最多时间给后面的活动。

**方法讲解：**

1. 排序（按结束时间）
2. 每次选当前能选的最早结束活动
3. 更新当前时间

**总结：**  
贪心算法的核心是：

> 每一步做出当前最优选择，整体也能达到最优。  
> 但要记住，**贪心的正确性需证明**。

常见类型：区间问题、最小代价问题、任务调度。

---

## 六、动态规划（Dynamic Programming, DP）

**问题引入：**  
求一个数组的最长上升子序列（LIS）长度。暴力解是 O(n²)，能更快吗？

**思路分析：**

- 发现子问题结构：LIS(i) 依赖于比 a[i] 小的元素。
- 状态转移方程：

  ```cpp
  dp[i] = max(dp[j] + 1) for all j < i and a[j] < a[i]
  ```

- 可用二分优化到 O(n log n)。

**方法讲解：**

1. 明确“状态是什么”（子问题定义）
2. 写出“状态转移方程”
3. 设初值、遍历顺序
4. 用表格或滚动数组实现

**总结：**  
动态规划的核心是：

> “把大问题分解成小问题，并复用已求出的结果。”

经典例题：背包问题、LCS、路径计数。

### 举例：背包问题

- **问题描述**：有 `n` 件物品，每件物品有重量 `w[i]` 和价值 `v[i]`，背包容量为 `W`，求最大价值。
- **状态定义**：`dp[i][j]` 表示前 `i` 件物品，在容量为 `j` 时的最大价值。
- **状态转移**：

  ```cpp
  dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]) if j >= w[i]
  dp[i][j] = dp[i-1][j] if j < w[i]
  ```

- **初值**：`dp[0][j] = 0 for all j`
- **遍历顺序**：`i` 从 `1` 到 `n`，`j` 从 `0` 到 `W`。
- **优化**：可用一维数组滚动优化空间复杂度。

---

## 七、图论（Graph Theory）

**问题引入：**  
城市之间有若干条路，求从 A 到 B 的最短距离。

**思路分析：**  
问题可抽象为图，点代表城市，边代表道路。  
我们要找的是最短路径问题，可以用 **Dijkstra**。

**方法讲解：**

- **表示方法**：邻接表/矩阵
- **常见算法：**
  - BFS/DFS：遍历
  - Dijkstra：最短路（正权）
  - Floyd / Bellman-Ford：多源或含负权
  - Kruskal / Prim：最小生成树
  - Topo Sort：有向无环图排序

**总结：**  
图论是竞赛中的**核心模块**之一，解决各种“连接关系”类问题。  
思维公式：

> 点 + 边 + 规则 → 用图建模 → 选算法。

---

## 🧩 总结回顾

| 模块     | 关键词     | 应用场景       |
| -------- | ---------- | -------------- |
| 快读快写 | IO 优化    | 大数据输入输出 |
| 数据范围 | 复杂度判断 | 选算法前置     |
| 模拟     | 规则实现   | 逻辑类题       |
| 高精度   | 大数计算   | 数学类题       |
| 贪心     | 局部最优   | 区间、调度     |
| 动态规划 | 状态转移   | 优化与计数     |
| 图论     | 路径与连通 | 网络、最短路   |

读完这部分内容之后，可以回到我们的 [课程路线](../../Routes/S2/) 页面
