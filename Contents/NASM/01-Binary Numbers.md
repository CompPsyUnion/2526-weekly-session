# Binary Numbers 二进制数

## 十进制（Base 10）的工作原理

- 十进制使用 0 到 9 共 10 个数字
- 数字的值是通过将每个位置上的数字乘以 10 的相应幂次再相加得到的
- 例如，$(1 \times 10^{1}) + (3 \times 10^{0}) = 10 + 3 = 13$

## 二进制（Base 2）的工作原理

- 二进制只使用两个值：0 和 1
- 它遵循与十进制相同的原理，但使用 2 的幂次
- 二进制到十进制的转换：将每个位置上的数字乘以 2 的相应幂次再相加。例如，二进制数 1010 转换为十进制是 $(1 \times 2^{3}) + (0 \times 2^{2}) + (1 \times 2^{1}) + (0 \times 2^{0}) = 8 + 0 + 2 + 0 = 10
$
- 为什么使用二进制：在计算机的底层，电路只有“开”（1）和“关”（0）两种状态，这与二进制的两个值完美对应，使其能够用电信号表示数据

## 十进制到二进制的转换

除 2 取余法

## 二进制加法（Binary Addition）

二进制加法与十进制加法类似，当和大于等于 2 时会产生进位

## 带符号二进制数（Signed Binary Numbers）

在底层编程中，数字通常以字节（Byte）为单位分组，一个字节包含八个比特（Bit）。为了表示正数或负数，我们使用最顶部的比特（最高位）作为符号位（Sign Bit）

- 0 表示正数
- 1 表示负数

## 二进制的二补数（Two's Complement）

简单的符号位表示法有一个问题：它不满足算术定律 $a + (-a) = 0$。为了在二进制运算中保持这个性质，负数需要使用二补数来表示

计算二补数的步骤：

- **取反（One's Complement）**：将正数的二进制表示中的所有比特取反（0 变 1，1 变 0）
- **加一**：将取反后的结果加 1

使用二补数表示的负数与正数相加时，结果会等于 0，而产生的进位（Carry）通常会被忽略或存入特殊的进位寄存器中。这种表示方法是低级编程中处理负数的标准方式。

以计算十进制数 $5$（二进制 $0101$）的二补数（即表示$-5$）为例：

- **取反（One's Complement）**：将正数的二进制所有比特取反，$0$ 变 $1$，$1$ 变 $0$。$5$ 的二进制是 $0101$，取反后得到 $1010$。
- **加一**：把取反后的结果加 $1$，$1010 + 0001 = 1011$，所以$-5$ 的二补数表示为 $1011$。

现在验证 $5 + (-5)\ $ 是否为 $0$。$5$ 的二进制是 $0101$，$-5$ 的二补数是 $1011$，两者相加：

$$
\begin{align*}
&0101\\
+&1011\\ =&10000
\end{align*}
$$

在 4 位二进制数的范围内，最高位的进位（这里是第 5 位的 $1$）通常会被忽略，剩下的 $0000$ 就是 $0$，满足 $a + (-a) = 0$ 的算术定律。这种表示方法是低级编程（如汇编语言编程）中处理负数的标准方式，因为它能让计算机用简单的加法电路来处理减法等运算（比如计算 $a - b$，可转化为 $a + (-b)$，其中$-b$ 用二补数表示）。
